\documentclass[12pt]{report}
\usepackage[a4paper,margin=1in]{geometry}
\usepackage{graphicx}
\usepackage{float}
\usepackage{booktabs}
\usepackage{longtable}
\usepackage{tabularx}
\usepackage{array}
\usepackage{hyperref}
\usepackage{fancyhdr}
\usepackage{enumitem}
\usepackage[dvipsnames]{xcolor}
\usepackage{listings}
\usepackage{caption}
\usepackage{amsmath}
\usepackage{xparse}

\graphicspath{{images/}}

\hypersetup{
  colorlinks=true,
  linkcolor=MidnightBlue,
  urlcolor=RoyalBlue,
  citecolor=ForestGreen,
  pdfauthor={Abdelilah Ikbi, Aymane Benmessaoud},
  pdftitle={System Monitoring with Kubernetes and Microservices}
}

\lstdefinestyle{bashstyle}{
  backgroundcolor=\color{black!5},
  basicstyle=\ttfamily\small,
  breaklines=true,
  frame=single,
  rulecolor=\color{black!40},
  keywordstyle=\color{RoyalBlue},
  commentstyle=\color{ForestGreen},
  stringstyle=\color{BrickRed}
}

\lstset{style=bashstyle}

\setlength{\headheight}{15pt}
\pagestyle{fancy}
\fancyhf{}
\rhead{INE3-SUD Monitoring}
\lhead{System Monitoring Lab}
\cfoot{\thepage}

% Helper commands
\newcommand{\toolversion}[2]{\textbf{#1}: #2}

\NewDocumentEnvironment{commandstep}{m m m +m}{%
  \subsubsection{#1}%
  \noindent\textbf{Command}
  \begin{lstlisting}[language=bash]
#4
  \end{lstlisting}
  \medskip
  \noindent\textbf{Description}\par
  #2\par\medskip
  \noindent\textbf{Screenshot Placeholder}\par
  \begin{figure}[H]
    \centering
    \IfFileExists{#3}{
      \includegraphics[width=0.85\textwidth]{#3}%
    }{
      \fbox{\parbox{0.8\textwidth}{Screenshot \texttt{#3} not found. Replace with actual capture.}}%
    }
    \caption{#1}
  \end{figure}
}{}

\begin{document}

\begin{titlepage}
  \centering
  {\Large INE3-SUD Monitoring Laboratory\\[1.5em]}
  {\Huge \textbf{System Monitoring with Kubernetes and Microservices}\\[1em]}
  {\large Comprehensive Lab Report}\
  \vfill
  \begin{tabular}{ll}
    Students:& Abdelilah Ikbi, Aymane Benmessaoud \\
    Instructor:& <<Instructor Name>> \\
    Date Submitted:& <<Submission Date>> \\
    Course:& Systems Monitoring and Observability \\
  \end{tabular}
  \vfill
  \textit{This report documents the complete execution of our lab, including the commands we ran, the outputs we observed, and the validations we performed.}
\end{titlepage}

\pagenumbering{roman}
\tableofcontents
\listoffigures
\listoftables
\clearpage
\pagenumbering{arabic}

\chapter{Introduction}
\section{Overview}
This lab consolidates monitoring concepts from prior modules (Parts 1--6) into a cohesive microservices deployment on Kubernetes. Our objective is to design, instrument, deploy, and observe a fictitious e-commerce system composed of multiple loosely coupled services. We leverage Prometheus for metrics, Grafana for visualization, Alertmanager for notifications, and optional integrations such as Loki for log aggregation and Jaeger for distributed tracing.

\section{Learning Objectives}
By the end of this lab, you will be able to:
\begin{enumerate}[label=\arabic*.]
  \item Design and deploy a small microservices system on Kubernetes.
  \item Instrument services with metrics, health checks, and structured logs.
  \item Configure Prometheus to scrape application and infrastructure metrics.
  \item Write PromQL queries and build Grafana dashboards.
  \item Implement alerting via Alertmanager and validate alert workflows.
  \item Monitor containers and Kubernetes objects (pods, nodes, deployments).
  \item Apply monitoring patterns (health checks, circuit breakers, tracing, SLO/SLI basics).
  \item Troubleshoot incidents using dashboards, metrics, and traces.
\end{enumerate}

\section{Prerequisites}
\begin{itemize}
  \item Docker or Podman installed and configured.
  \item Kubernetes access via \texttt{minikube}, \texttt{kind}, or a managed cluster.
  \item \texttt{kubectl}, \texttt{helm} (v3+), \texttt{git}, and \texttt{curl} available on the workstation.
  \item Code editor or IDE for editing manifests and source code.
\end{itemize}

\section{Lab Topology}
The demonstrator microservices system comprises the following workloads:
\begin{itemize}
  \item \textbf{api-gateway}: Routes external traffic to backend services (NGINX or Node.js).
  \item \textbf{order-service}: Accepts orders, emits business events, and exposes domain metrics.
  \item \textbf{inventory-service}: Manages stock counts with Prometheus endpoints.
  \item \textbf{frontend}: Generates traffic and mimics end-user behavior.
  \item \textbf{user-service} (optional): Handles user data and authentication flows.
  \item \textbf{payment-service} (optional): Simulates payment processing and retries.
  \item Support stack: Prometheus, Alertmanager, Grafana, kube-state-metrics, node-exporter.
  \item Optional observability: Loki or EFK for logs, Jaeger for tracing.
\end{itemize}

Figure~\ref{fig:topology} illustrates the logical architecture and monitoring data flow.

\begin{figure}[H]
  \centering
  \IfFileExists{architecture/topology.png}{
    \includegraphics[width=0.9\textwidth]{architecture/topology.png}%
  }{
    \fbox{\parbox{0.85\textwidth}{Architecture diagram \texttt{architecture/topology.png} not found. Upload the image or update the path.}}%
  }
  \caption{End-to-end topology of the monitored microservices system.}
  \label{fig:topology}
\end{figure}

\chapter{Part 1: Environment Setup}
This section documents the initialization of the Kubernetes environment, namespace organization, monitoring stack deployment, and verification procedures. Replace placeholder screenshot paths with actual captures collected during the lab.

\section{Cluster Initialization and Add-ons}

\begin{commandstep}{Start Local Kubernetes Cluster}{Bootstraps a single-node Kubernetes cluster with essential monitoring add-ons and ingress routing enabled.}{screenshots/part1/minikube-start.png}{%
minikube start \\
  --kubernetes-version=v1.29.0 \\
  --cpus=4 --memory=8192 \\
  --addons=ingress,metrics-server,dashboard
}
\end{commandstep}

\begin{commandstep}{Configure kubectl Context}{Ensures \texttt{kubectl} commands target the freshly created cluster context.}{screenshots/part1/kubectl-context.png}{%
kubectl config use-context minikube
}
\end{commandstep}

\section{Namespace Strategy}
\begin{commandstep}{Create Namespaces}{Creates logical isolation for monitoring components, staging workloads, and production-ready services. Adjust namespaces to your organizational standards.}{screenshots/part1/create-namespaces.png}{%
kubectl create namespace monitoring
kubectl create namespace staging
kubectl create namespace production
}
\end{commandstep}

\section{Monitoring Stack Deployment}
\begin{commandstep}{Add Helm Repositories}{Registers upstream chart repositories required for deploying observability tooling.}{screenshots/part1/helm-repo-add.png}{%
helm repo add prometheus-community https://prometheus-community.github.io/helm-charts
helm repo add grafana https://grafana.github.io/helm-charts
helm repo update
}
\end{commandstep}

\begin{commandstep}{Deploy kube-prometheus-stack}{Installs Prometheus, Alertmanager, Grafana, kube-state-metrics, and node-exporter with curated configuration overrides.}{screenshots/part1/kube-prometheus-install.png}{%
helm upgrade --install kube-prom-stack prometheus-community/kube-prometheus-stack \\
  --namespace monitoring \\
  --create-namespace \\
  --values k8s/monitoring/values.yaml
}
\end{commandstep}

\begin{commandstep}{Retrieve Grafana Credentials}{Extracts Grafana administrator credentials for dashboard access.}{screenshots/part1/grafana-credentials.png}{%
kubectl get secret --namespace monitoring kube-prom-stack-grafana \\
  -o jsonpath="{.data.admin-user}" | base64 --decode
kubectl get secret --namespace monitoring kube-prom-stack-grafana \\
  -o jsonpath="{.data.admin-password}" | base64 --decode
}
\end{commandstep}

\section{Verification}
\begin{commandstep}{Validate Pods}{Confirms all monitoring components reach a running state. Investigate crash loops before proceeding.}{screenshots/part1/monitoring-pods.png}{%
kubectl get pods --namespace monitoring
}
\end{commandstep}

\begin{table}[H]
  \centering
  \caption{Monitoring Stack Components}
  \begin{tabularx}{\textwidth}{@{}lX@{}}
    \toprule
    Component & Description \\
    \midrule
    Prometheus & Scrapes service and infrastructure metrics via service discovery. \\
    Alertmanager & Handles alert routing, deduplication, and notifications. \\
    Grafana & Provides dashboards and alert visualization. \\
    kube-state-metrics & Exposes Kubernetes object metrics (deployments, pods, nodes). \\
    node-exporter & Publishes node-level metrics (CPU, memory, filesystem). \\
    grafana-sc-dashboard & ConfigMaps delivering prebuilt dashboards. \\
    prometheus-operator & Manages CRDs for ServiceMonitors, PodMonitors, and alerting rules. \\
    \bottomrule
  \end{tabularx}
\end{table}

\chapter{Part 2: Deploy Core Microservices and Instrumentation}
This part covers service design, instrumentation, containerization, CI/CD automation, and end-to-end validation.

\section{Architecture and Design}
We document the logical interactions, including circuit breaker flows between \texttt{order-service} and \texttt{inventory-service}, and the routing responsibilities of the \texttt{api-gateway}. Figure~\ref{fig:topology} (or an updated diagram) reflects any optional services we include.

\section{Service Implementation Checklist}
\begin{enumerate}[label=\alph*)]
  \item Implement RESTful endpoints for each microservice with OpenAPI documentation.
  \item Expose \texttt{/metrics} in Prometheus exposition format using libraries such as Prometheus client for Node.js, Python, or Go.
  \item Provide \texttt{/healthz} and \texttt{/ready} endpoints for liveness and readiness probes.
  \item Emit structured logs (JSON) including correlation IDs to facilitate tracing alignment.
  \item Integrate OpenTelemetry SDKs to capture spans and propagate trace context.
\end{enumerate}

\section{Container Builds}
\begin{commandstep}{Build and Push Containers}{Builds each microservice image and pushes it to the project container registry. Replace the registry URL with the appropriate endpoint (Docker Hub, GHCR, or self-hosted).}{screenshots/part2/build-push.png}{%
REGISTRY=registry.example.com/monitoring-lab
for svc in api-gateway frontend order-service inventory-service; do
  docker build -t "$REGISTRY/$svc:$(git rev-parse --short HEAD)" services/$svc
  docker push "$REGISTRY/$svc:$(git rev-parse --short HEAD)"
done
}{Builds each microservice image and pushes it to the project container registry. Replace the registry URL with the appropriate endpoint (Docker Hub, GHCR, or self-hosted).}

\begin{commandstep}{Trigger CI Pipeline}{Pushes code changes to GitHub (or GitLab), triggering the CI/CD pipeline defined in \texttt{.github/workflows/ci.yml}.}{screenshots/part2/ci-pipeline.png}{%
git add .
git commit -m "feat: deploy monitoring lab services"
git push origin main
}{Pushes code changes to GitHub (or GitLab), triggering the CI/CD pipeline defined in \texttt{.github/workflows/ci.yml}.}
\end{commandstep}

\section{Kubernetes Deployment}
\begin{commandstep}{Apply Manifests}{Deploys core services, configuration maps, and ingress rules. Ensure manifests include appropriate \texttt{ServiceMonitor} and \texttt{PodMonitor} resources for Prometheus.}{screenshots/part2/kubectl-apply.png}{%
kubectl apply -f k8s/namespaces.yaml
kubectl apply -f k8s/base-configmaps.yaml
kubectl apply -f k8s/api-gateway
kubectl apply -f k8s/order-service
kubectl apply -f k8s/inventory-service
kubectl apply -f k8s/frontend
}
\end{commandstep}

\begin{commandstep}{Validate Deployments}{Confirms the availability of deployments and ingress routing.}{screenshots/part2/deployments.png}{%
kubectl get deployments -n staging
kubectl get svc -n staging
kubectl describe ingress api-gateway -n staging
}
\end{commandstep}

\section{Functional Verification}
\begin{commandstep}{Generate Test Traffic}{Validates the end-to-end order flow through gateway, order-service, and inventory-service. Capture the JSON response and corresponding logs.}{screenshots/part2/test-traffic.png}{%
curl -X POST https://$INGRESS_HOST/api/v1/orders \\
  -H "Content-Type: application/json" \\
  -d '{"sku": "SKU-123", "quantity": 2, "customerId": "user-42"}'
}
\end{commandstep}

\begin{commandstep}{Frontend Smoke Test}{Obtains the externally accessible URL for the \texttt{frontend} service and verifies UI functionality.}{screenshots/part2/frontend.png}{%
minikube service frontend -n staging --url
}
\end{commandstep}

\chapter{Part 3: Prometheus Scraping Configuration}

\section{Service Monitoring Resources}
Prometheus discovers scrape targets via \texttt{ServiceMonitor} and \texttt{PodMonitor} Custom Resource Definitions (CRDs). The following snippet exemplifies a \texttt{ServiceMonitor} for the \texttt{order-service}.

\begin{lstlisting}[language=yaml,caption={ServiceMonitor for order-service},label={lst:ordermonitor}]
apiVersion: monitoring.coreos.com/v1
kind: ServiceMonitor
metadata:
  name: order-service
  namespace: monitoring
  labels:
    release: kube-prom-stack
spec:
  selector:
    matchLabels:
      app: order-service
  namespaceSelector:
    matchNames:
      - staging
  endpoints:
    - port: http-metrics
      interval: 15s
      scrapeTimeout: 10s
      path: /metrics
      metricRelabelings:
        - sourceLabels: [ handler ]
          regex: ".*admin.*"
          action: drop
\end{lstlisting}

\section{Scrape Configuration Workflow}
\begin{commandstep}{Apply Monitoring Resources}{Registers microservice targets with Prometheus. Confirm the \texttt{kube-prometheus-stack} operator reconciles the configuration without errors.}{screenshots/part3/service-monitor.png}{%
kubectl apply -f k8s/monitoring/service-monitors.yaml
kubectl get servicemonitor -n monitoring
}
\end{commandstep}

\begin{commandstep}{Inspect Prometheus Targets}{Forwards Prometheus UI locally. Use the Targets tab to verify that \texttt{order-service}, \texttt{inventory-service}, and supporting workloads are labeled \emph{UP}. Document discovered labels and scrape status.}{screenshots/part3/prometheus-targets.png}{%
kubectl port-forward svc/kube-prom-stack-prometheus -n monitoring 9090:9090
}
\end{commandstep}

\section{Metrics Validation}
\begin{commandstep}{Query Metrics}{Executes PromQL queries to validate request volumes and response status distribution. Capture query results and note observed traffic trends.}{screenshots/part3/promql.png}{%
# Example PromQL queries
sum(rate(http_requests_total{service="order-service"}[5m]))
sum by (status) (rate(http_requests_total{service="api-gateway"}[1m]))
}
\end{commandstep}

\chapter{Part 4: Visualization with Grafana}

\section{Grafana Access}
\begin{commandstep}{Port-forward Grafana}{Exposes Grafana locally on \texttt{http://localhost:3000} for dashboard management.}{screenshots/part4/grafana-login.png}{%
kubectl port-forward svc/kube-prom-stack-grafana -n monitoring 3000:80
}
\end{commandstep}

\section{Dashboard Customization}
We document the dashboards we create for the microservices environment. We include panels for:
\begin{itemize}
  \item CPU, memory, and pod restarts per service.
  \item Request rate, error rate, and latency histograms from \texttt{order-service} and \texttt{api-gateway}.
  \item Business KPIs such as orders per minute and stock depletion events.
\end{itemize}

\begin{commandstep}{Create Dashboard Panels}{Configures Grafana panels to visualize business and platform metrics. Include screenshots of completed dashboards and highlight thresholds or annotations.}{screenshots/part4/grafana-dashboard.png}{%
# Example PromQL expressions for panels
sum(rate(order_service_orders_total[5m]))
quantile(0.99, histogram_quantile(0.99,
  sum(rate(http_request_duration_seconds_bucket{service="api-gateway"}[5m])) by (le)))
}
\end{commandstep}

\section{Trace Correlation}
If Jaeger or another tracing backend is enabled, document how trace IDs captured in logs map to Grafana panels via exemplars. Provide a screenshot of the trace waterfall to demonstrate request propagation across services.

\chapter{Part 5: Alert Configuration and Management}

\section{Alerting Rules}
Define alert policies based on Service-Level Indicators. The snippet below illustrates multi-window, multi-burn-rate alerts for HTTP error ratios.

\begin{lstlisting}[language=yaml,caption={Alertmanager rule for order-service},label={lst:alertrule}]
apiVersion: monitoring.coreos.com/v1
kind: PrometheusRule
metadata:
  name: order-service-alerts
  namespace: monitoring
  labels:
    release: kube-prom-stack
spec:
  groups:
    - name: order-service.slo
      rules:
        - alert: OrderServiceHighErrorRate
          expr: |
            (
              sum(rate(http_requests_total{service="order-service",status!~"2.."}[5m]))
            /
              sum(rate(http_requests_total{service="order-service"}[5m]))
            ) > 0.05
          for: 10m
          labels:
            severity: critical
          annotations:
            summary: "Order service error rate above 5\%"
            description: |
              High error ratio detected for order service across the last 10 minutes.
\end{lstlisting}

\begin{commandstep}{Deploy Alert Rules}{Registers alert definitions. Confirm Prometheus loads the rule group without syntax errors via the `/rules` endpoint.}{screenshots/part5/alert-rules.png}{%
kubectl apply -f k8s/monitoring/alert-rules.yaml
kubectl get prometheusrule -n monitoring
}
\end{commandstep}

\begin{commandstep}{Configure Alertmanager Receivers}{Updates alert routing to include email, Slack, or PagerDuty receivers. Redact secrets and tokens from the report.}{screenshots/part5/alertmanager-config.png}{%
kubectl apply -f k8s/monitoring/alertmanager-config.yaml
}
\end{commandstep}

\section{Alert Testing}
\begin{commandstep}{Simulate Alert Condition}{Generates synthetic load to breach error thresholds. Document the resulting alert in Alertmanager and Grafana Alerting.}{screenshots/part5/alert-fired.png}{%
kubectl exec deploy/order-service -n staging -- \\
  hey -z 5m -q 50 -c 20 http://localhost:8080/api/v1/orders
}
\end{commandstep}

\chapter{Observability Analysis and Incident Response}
\section{Runbooks and Playbooks}
We summarize remediation actions for common incidents (high latency, pod crash loops, inventory desynchronization). We include links to runbooks or create an appendix with escalation procedures.

\section{Post-Incident Review}
We capture metrics, logs, and trace evidence collected during alert simulations. We provide a concise narrative describing investigation, root cause identification, and mitigations applied.

\chapter{Conclusions}
We reflect on the outcomes of the lab. Specifically, we discuss:
\begin{itemize}
  \item Key observability insights gained.
  \item Improvements to instrumentation or alerting discovered during the exercise.
  \item Suggested future work (e.g., canary deployments, chaos engineering, SLO dashboards).
\end{itemize}

\appendix
\chapter{Appendix A: Kubernetes Manifests}
Include trimmed versions of essential manifests (Deployments, Services, Ingresses, ServiceMonitors) with redacted secrets.

\chapter{Appendix B: PromQL Reference}
Provide the top PromQL queries leveraged in the report with explanations for each metric analyzed.

\chapter{Appendix C: CI/CD Pipeline Overview}
Document the CI/CD workflow file (GitHub Actions, GitLab CI, or Jenkins pipeline), including stages for linting, unit testing, container builds, security scanning, and deployment gating.

\chapter{Appendix D: Troubleshooting Checklist}
\begin{longtable}{@{}p{0.3\textwidth}p{0.65\textwidth}@{}}
  \toprule
  Symptom & Diagnostic Steps \\
  \midrule
  Pods pending scheduling & Check node resources with \texttt{kubectl describe nodes}; ensure resource requests fit. \\
  Missing metrics in Prometheus & Validate ServiceMonitor selectors, namespace selectors, and TLS configuration. \\
  Grafana dashboards empty & Verify datasource configuration and query range; inspect Prometheus `/targets`. \\
  Alerts not firing & Confirm rule evaluation intervals and Alertmanager silence state; inspect routing tree. \\
  CI pipeline failure & Review build logs, test results, and container registry credentials. \\
  \bottomrule
\end{longtable}
\end{document}
